<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
        #myCanvas {
            border: 1px solid black;
            background-color: lightgrey;
        }
    </style>
</head>

<body>

<canvas id="myCanvas" width="680px" height="500px">
</canvas>
<div>Time Remaining <span id="time"></span></div>
<div>Total Score: <span id="scoreBoard"></span></div>
<button onClick="gameStartfunction ()">Start</button>
<script>
    var canvas = document.getElementById("myCanvas");
    canvas.onmousedown = myDown;
    canvas.onmousemove = myMove;
    canvas.onmouseup = myUp;

    var ctx = canvas.getContext("2d");
    var diff, gInterval;
    var totalScore = 0;
    var scoreBoard = new ScoreBoard();
    var circleBoard = new CircleBoard();
    var recPiece = new Rectangle();
    var cirPiece = new Circle();
    var recScoreBoard=new pieceScoreBoard(150,480, "RecScore: ");
    var cirScoreBoard=new pieceScoreBoard(400,480, "CirScore: ");

    function Rectangle() {
        var width = 60;
        var height = 60;
        var color = "red";
        var defaultX = 25;
        var defaultY = 35;
        var _x = defaultX, _y = defaultY;
        var draggable2 = false;

        // This again is against OOP. Should use an instance varaible instead.
        this.shapeId = null;
        paint(_x, _y);
        this.update = function (x, y) {
            if (draggable2) {
                ctx.clearRect(_x, _y, width, height);
                paint(x, y);
                _x = x;
                _y = y;
            }
        };
        this.onMouseDown = function (x, y) {
            if (x < _x + width && x > _x && y < _y + height && y > _y) {
                draggable2 = true;
                // This should not be done here. It should be done in the onScore method.
                this.shapeId = "rectangle";
            }
        }
        this.onScore = function () {
            draggable2 = false;
            _x = defaultX;
            _y = defaultY;
            paint(_x, _y);
            // This method should return the type of shape.
        }

        function paint(x, y) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
        }
    }


    function Circle() {
        var radius = 35;
        var color = "blue";
        var defaultX = 600;
        var defaultY = 60;
        var _x = defaultX, _y = defaultY;
        // This again is against OOP. There is no need for this variable if you let onScore to accept x and y coordinates.
        this.shapeId = null;
        // Deleted unused code.
       // var cirShape=false;
        paint(_x, _y);
        this.update = function (x, y) {
            if (draggable1) {
                ctx.clearRect(_x - radius, _y - radius, 2 * radius, 2 * radius);
                paint(x, y);
                _x = x;
                _y = y;
            }
        };

        this.onMouseDown = function (x, y) {
            if (x < _x + radius && x > _x - radius && y < _y + radius && y > _y - radius) {
                draggable1 = true;
                // There is no need for this line of code at all.
                this.shapeId="circle";
            }

        }
        // This method should take two input paramaters, x and y. It should decide if x and y are within its area.
        this.onScore = function () {
            draggable1 = false;
            _x = defaultX;
            _y = defaultY;
            paint(_x, _y);
            // This method should return the type of shape.
        }

        function paint(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
        }
    }


    function ScoreBoard() {
        var x = 200;
        var y = 350;
        var radiusX = 60;
        var radiusY = 30;
        var h = 70;
        var boundaryWidth = 40;
        var rotation = 0;
        var startAngle = 0;
        var endAngle = 2 * Math.PI;
        ctx.beginPath();
        ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);
        ctx.moveTo((x - radiusX), y);
        ctx.lineTo((x - radiusX), (y + h));
        ctx.lineTo((x + radiusX), (y + h));
        ctx.lineTo((x + radiusX), y);
        ctx.lineWidth = 4;
        ctx.strokeStyle = "orange";
        ctx.stroke();

        this.getScore = function (sx, sy) {
            // shapeType
            // Again this is a BAD violation of OOP. Why the board is telling the shape what to do???
            if (this.isOnScoreBoard(sx, sy)&&recPiece.shapeId==="rectangle") {
                recScoreBoard.update();
                updatScore(totalScore);
                recPiece.onScore();
                ctx.clearRect(x-radiusX, y-radiusY, 2*radiusX, 3.5*radiusY);
                repaint();
            }
        }

        this.isOnScoreBoard = function (sx, sy) {
            return sx < x + boundaryWidth && sx > x - boundaryWidth && sy < y + boundaryWidth && sy > y - boundaryWidth;
        }

        function repaint() {
            ScoreBoard();
        }
    }


    function CircleBoard() {
        var x = 450;
        var y = 370;
        var radius = 50;
        ctx.beginPath();
        // Use local variables to replace ALL magic numbers.
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.lineWidth = 4;
        ctx.strokeStyle = "orange";
        ctx.stroke();
        this.getScore = function (sx, sy) {

            if (this.isOnScoreBoard(sx, sy)&&cirPiece.shapeId==="circle") {
                cirScoreBoard.update();
                updatScore(totalScore);
                cirPiece.onScore();
                // Use local variables to replace ALL magic numbers.
                ctx.clearRect(x-radius, y-radius, 2*radius, 2*radius);
                repaint();
            }
        }

        this.isOnScoreBoard = function (sx, sy) {
            return sx < x + radius && sx > x - radius && sy < y + radius && sy > y - radius;
        }

        function repaint() {
            CircleBoard();
        }
    }


    function pieceScoreBoard(x, y, displayText) {
        var score = 0;
        var fontHeight = 20;
        var color = "black";
        var display =displayText;
        paint();
        this.update = function () {
            score+=1;
            totalScore+=1;
           paint();

        }

        function paint(){
            ctx.font = fontHeight + "px Arial";
            var txt = display + score;
            ctx.fillStyle = color;
            ctx.clearRect(x, y - fontHeight, ctx.measureText(txt).width, fontHeight);
            ctx.fillText(txt, x, y);
        }


    }


    function myMove(e) {
        var mx = e.pageX - canvas.offsetLeft;
        var my = e.pageY - canvas.offsetTop;

        recPiece.update(mx, my);
        cirPiece.update(mx, my);
    }


    function myDown(e) {
        e.preventDefault();
        var newX = e.pageX - canvas.offsetLeft;
        var newY = e.pageY - canvas.offsetTop;
        if (!scoreBoard.isOnScoreBoard(newX, newY) && !circleBoard.isOnScoreBoard(newX, newY)) {
            recPiece.onMouseDown(newX, newY);
            cirPiece.onMouseDown(newX, newY);
        }
    }


    function updatScore(totalScore) {
        document.getElementById("scoreBoard").innerHTML = totalScore;
    }


    function myUp(e) {
        var cx = e.pageX - canvas.offsetLeft;
        var cy = e.pageY - canvas.offsetTop;
       // var shapeType = e.currentTarget;
       // console.log("shapeType", shapeType);
        scoreBoard.getScore(cx, cy);
        circleBoard.getScore(cx, cy);


    }


</script>
</body>
</html>